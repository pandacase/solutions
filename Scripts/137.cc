
#include <vector>
#include <iostream>
#include <tuple>


//! @brief 
//! 给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。
//! 请你找出并返回那个只出现了一次的元素。
//! 你必须设计并实现线性时间复杂度的算法且使用常数级空间来解决此问题。
//! 
//! @details 
//! 1 <= nums.length <= 3 * 10^4
//! -2^31 <= nums[i] <= 2^31 - 1
//! nums 中，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次
//! 
//! @note
//! 对于每个数的每一个比特，统计 1 的次数，然后对 3 取余必定得到 0 或 1，
//! 所有位组合起来实际上就是该只出现一次的数字。
//! 
//! 如果单纯是计数之后取余，需要对每一个数遍历位宽次次数。
//! 故可以将逻辑设计成数字电路，使用单纯的位运算来解决，不依赖常规运算。
//! 这样便可以做到只需要遍历 O(n)，对每一个数执行一次位表达式运算。
//! 
//! 对于每一位来说，在计数的过程中，无非是在 0->1->2 这三个数循环，
//! 并且最终求和结果一定是 0 或者 1.
//! 需要使用 2 bits 来存储这一中间信息，假设对于*某一位*的求和过程来说
//! 这一中间过程信息使用 a、b 来标识，而遇到的新数字的该位 x 可能是 0 或 1.
//! 得到的新结果是 a'、b'，构造真值表如下：
//!   |  a  |  b  |  x  |  a' |  b' |
//!   |  0  |  0  |  0  |  0  |  0  |
//!   |  0  |  0  |  1  |  0  |  1  |
//!   |  0  |  1  |  0  |  0  |  1  |
//!   |  0  |  1  |  1  |  1  |  0  |
//!   |  1  |  0  |  0  |  1  |  0  |
//!   |  1  |  0  |  1  |  0  |  0  |
//! 对应的布尔表达式为：
//!   a' = ~a · b · x + a · ~b · ~x
//!   b' = ~a · ~b · x + ~a · b · ~x = ~a (b ⊕ x)
//! 
class Solution {
public:
  int 
  singleNumber(std::vector<int>& nums) 
  {
    int a = 0, b = 0;
    for (int num : nums) {
      std::tie(a, b) = std::pair{
        (~a & b & num) | (a & ~b & ~num), 
        ~a & (b ^ num)
      };
    }
    return b;
  }
};


int main() {
  Solution sol;
  std::vector<int> nums{2, 2, 3, 2};
  auto ans = sol.singleNumber(nums);

  // print link
  std::cout << ans << std::endl;
}
