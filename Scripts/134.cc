#include <vector>
#include <iostream>

//! @brief 在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。
//! 你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要
//! 消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。
//! 给定两个整数数组 gas 和 cost ，如果你可以按顺序绕环路行驶一周，则返回
//! 出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。
//!
//! @details
//! gas.length == n
//! cost.length == n
//! 1 <= n <= 105
//! 0 <= gas[i], cost[i] <= 104
//! 
//! @example 
//! input:  gas = [1,2,3,4,5], cost = [3,4,5,1,2]
//! output: 3
//! 从 3 号加油站(索引为 3)出发，可获得 4 升汽油。此时油箱有 0 + 4 升汽油
//! 开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
//! 开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
//! 开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
//! 开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
//! 开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
//! 因此，3 可为起始索引。
//! input:  gas = [2,3,4], cost = [3,4,3]
//! output: -1
//! 你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。
//! 我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油
//! 开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油
//! 开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油
//! 你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。
//! 因此，无论怎样，你都不可能绕环路行驶一周。
//!  
//! @note
//! 基于一个事实：如果从 x 可以到达 y 但是无法到达 y+1，
//! 那么任何 z 在 [x, y] 之间的点也无法到达 y+1。
//! 因为从 x 到 y 途径 z 时，因为可以继续前进，余额一定是 >= 0 的，也就是说只可能
//! 为 z 到 y+1 的前进添加汽油，而不会消耗其汽油。所以在有余额补贴的情况下依然到不了,
//! 若没有从 x 到 z 的补贴，则更不可能到达 y+1 了。
//! 综上所述，最多遍历 2n 即可完成。
class Solution {
public:
  int 
  canCompleteCircuit(std::vector<int>& gas, std::vector<int>& cost) 
  {
    int size = gas.size();
    for (int i = 0; i < size; ++i) {
      int cumuGas = 0, cumuCost = 0;
      int step = 0;
      for (; step < size; ++step) {
        int pos = (i + step) % size;
        cumuGas += gas[pos];
        cumuCost += cost[pos];
        if (cumuGas < cumuCost) {
          i += step;
          break;
        }
      }

      if (step == size) return i;
    }
    return -1;
  }
};