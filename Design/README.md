
## Design Pattern

> 怎么来的？

软件开发过程中的一些固定套路，由程序员们慢慢迭代总结经验得出的。

> 解决了什么？

希望修改少量的代码来适应需求的变化。这说明项目中既有**稳定点**又有**变化点**。

（全是变化点一般使用脚本语言，比如游戏开发中会用到 lua）

> 如何使用？

明确项目中的稳定点和变化点，选择合适的设计模式。（以下许多实现例子依赖于 C++ 面向对象语言特性）

1. 最小知道原则：一个对象应当对其他对象有尽可能少的了解（即限制对象间的通信）。
  在一个复杂系统中，如果每个类都直接访问其他类的内部细节，系统将变得非常脆弱。当一个类发生变化时，其他依赖类也会受到影响。因此，通过减少对象之间的依赖性，可以增强系统的可维护性和可扩展性。
1. 单一职责原则：每个类应该只有一个引起其变化的原因，即每个类只负责一个单一的功能或职责。
   如果一个类承担了多个职责，意味着这个类的变化可能来自于多个方面。为了解耦，我们需要让每个类只关注单一职责，从而减少类的修改频率和复杂度。
2. 接口隔离原则：客户端不应该被迫依赖它们不使用的方法。换句话说，接口应该尽可能小，且专注于特定功能。

### 0. 模板模式 Template Modthod

模板模式是其他许多模式的基础，有非常典型的设计模式思维。

> 解决的问题

稳定点：算法骨架
变化点：具体算法的实现（通过子类虚函数重写）

### 1. 策略模式 Strategy

> 解决的问题

- 稳定点：客户程序与算法的调用关系
- 变化点：新增算法 / 算法内部实现

> 代码结构

- 算法的抽象接口：用于解耦合
- 算法具体实现：继承自算法接口
- 算法调用者：
  - 组合算法接口指针
  - 具体切换算法
  - 依赖注入

> 应用案例

- 后端日志系统：可以写入 DB / kafka / 本机（temp）

### 2. 责任链模式 Chain of Responsibility

> 解决的问题

- 稳定点：请求按照链条传递处理（一般通过链表，中间可能发生条件打断）
- 变化点：处理结点的个数/顺序/逻辑会发生变化

> 代码结构

- 单个处理模块
  - 抽象接口
  - 实际处理请求的功能
  - 链条关系的基础：next / SetNext / GetNext
  - 功能传递：模板方法 / 算法骨架
- 工程模式实现构建链条
  - 工厂方法中生成多个处理模块
  - 构建模块关系
  - 返回链条头指针

> 应用案例

- nginx 处理 http 请求
  ```cpp
  // 处理方法的一维数组
  ph = cmcf->phase_engine.handlers;
  while (ph[r->phase_handler].checker) {
    // 阶段执行与跳跃
    rc = ph[r->phase_handler].checker(r, &ph[r->phase_handler]);
    // 打断责任链
    if (rc == NGX_OK)
      return;
  }
  ```

### 3. 组合模式

将对象组合成树形结构以表示 “部分-整体” 的层次结构。
